{"mappings":";;AAOA,8BAA8B;IAC5B;;OAEG;IACH,aAAa,CAAC,EAAE,aAAa,CAAC;IAE9B;;OAEG;IACH,aAAa,CAAC,EAAE,aAAa,CAAC;CAC/B,CAAC;AAEF,qBAAqB,eAAe,GAAG;IACrC;;;;OAIG;IACH,aAAa,EAAE,MAAM,CAAC;IAEtB;;;;;OAKG;IACH,cAAc,CAAC,EAAE;QACf;;WAEG;QACH,SAAS,EAAE,MAAM,CAAC;QAClB;;WAEG;QACH,MAAM,EAAE,MAAM,CAAC;KAChB,CAAC;IAEF;;OAEG;IACH,UAAU,CAAC,EAAE,CAAC,CAAC,SAAS,eAAe,EAAE,IAAI,EAAE,IAAI,EAAE,WAAW,EAAE,CAAC,KAAK,OAAO,CAAC;IAEhF;;OAEG;IACH,KAAK,CAAC,EAAE,OAAO,CAAC;CACjB,CAAC;AAEF,8BAA8B;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,CAAC;AAErD,kBAAkB;IAChB,IAAI,EAAE,KAAK,CAAC;IACZ,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,UAAU,EAAE,CAAC;CACxB,CAAC;AAEF,mBAAmB;IACjB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,MAAM,CAAC;CACd,CAAC;AAEF,yBAAyB,GAAG,GAAG,IAAI,CAAC;AAEpC;IACE,IAAI,EAAE,MAAM,CAAC;IACb,EAAE,EAAE,MAAM,CAAC;IACX,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7B,QAAQ,EAAE,kBAAkB,EAAE,CAAC;CAChC;AAED,8BAA8B,kBAAkB,EAAE,CAAC;AAEnD,8BAA8B,CAAC,SAAS,eAAe,EAAE,CAAC,SAAS,eAAe,GAAG,CAAC,IAAI,iBAAiB,CAAC,CAAC,GAAG;IAC9G,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,SAAS,EAAE,yBAAyB,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC;IACpE,eAAe,EAAE,eAAe,CAAC;IACjC,QAAQ,EAAE,iBAAiB,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC;CACxC,CAAC;AAEF,6BAA6B,CAAC,SAAS,eAAe,IAAI;IACxD,MAAM,EAAE,MAAM,EAAE,CAAC;IACjB,WAAW,EAAE,CAAC,CAAC;IACf,QAAQ,EAAE,MAAM,CAAC;CAClB,CAAC;AQrFF;;;GAGG;AACH,QAAA,MAAM,YAAY,qEAAsE,MAAM;;;;;;;;;;;oBA4FrC,MAAM,EAAE;;;;;gGAzDrD,MAAM,EAAE;;;CAiEnB,CAAC;AAEF,eAAe,YAAY,CAAC","sources":["src/src/types.ts","src/src/utils/fs.ts","src/src/utils/cmd.ts","src/src/utils/logger.ts","src/src/utils/git.ts","src/src/utils/alt.ts","src/src/utils/table-of-contents.ts","src/src/utils/markdown.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,"import { resolve, relative } from 'path';\nimport { Config, File, NextMarkdownFile, NextMarkdownProps, YAMLFrontMatter } from './types';\nimport { pathToContent, flatFiles, generateNextmd, readFileSyncUTF8, isDraft } from './utils/fs';\nimport { treeContentRepo } from './utils/git';\nimport { consoleLogNextmd } from './utils/logger';\nimport { extractFrontMatter, readMarkdownFile } from './utils/markdown';\n\n/**\n * @param config The config for the next-markdown module.\n * @returns The next markdown module ready-to-use.\n */\nconst NextMarkdown = <T extends YAMLFrontMatter, U extends YAMLFrontMatter = T>(config: Config) => {\n  const isContentFetchedFromRemote = config.contentGitRepo !== undefined;\n  const finalPathToContent = pathToContent(config.pathToContent, isContentFetchedFromRemote);\n  const relativeToAbsolute = (filePath: string) => resolve(finalPathToContent, filePath);\n  const absoluteToRelative = (filePath: string) => relative(finalPathToContent, filePath);\n\n  const getAllFiles = async () => {\n    const filterFileFinal = async (file: File) =>\n      config.filterFile\n        ? (async (fn: typeof config.filterFile) => {\n            const rawdata = readFileSyncUTF8(relativeToAbsolute(file.path));\n            const { frontMatter } = extractFrontMatter(rawdata);\n            return fn(file, frontMatter);\n          })(config.filterFile)\n        : file.name !== 'README.md';\n\n    const tree = await treeContentRepo(\n      relativeToAbsolute('.'),\n      absoluteToRelative,\n      config.debug ?? false,\n      config.contentGitRepo,\n    );\n\n    const allFiles = await Promise.all(\n      flatFiles(tree).map(async (e) => ({ file: e, isIncluded: await filterFileFinal(e) })),\n    );\n\n    if (config.debug) {\n      consoleLogNextmd('Files:', JSON.stringify(allFiles));\n    }\n\n    return allFiles.filter((e) => e.isIncluded).map((e) => e.file);\n  };\n\n  const getStaticPropsForNextmd = async <R extends YAMLFrontMatter, S extends YAMLFrontMatter = R>(\n    nextmd: string[],\n  ): Promise<{ props: NextMarkdownProps<R, S> }> => {\n    const allFiles = await getAllFiles();\n\n    const file = allFiles.find((e) => JSON.stringify(nextmd) === JSON.stringify(generateNextmd(e.path)));\n\n    if (file === undefined) {\n      throw Error(`Could not find markdown file at path \"${nextmd.join('/')}\"`);\n    }\n\n    const pageData = await readMarkdownFile<R>(relativeToAbsolute(file.path), config);\n\n    const subPaths = allFiles\n      .filter((e) => e !== file) // remove itself\n      .filter((e) => isDraft(e.path) === false) // exclude draft or unpublished\n      .map((e): NextMarkdownFile<S> | null => {\n        // compare file's nextmd with the given nextmd\n        const fileNextmd = generateNextmd(e.path);\n        const parentNextmd = fileNextmd.slice(0, -1); // remove last element\n        if (JSON.stringify(nextmd) === JSON.stringify(parentNextmd)) {\n          const { frontMatter, content } = extractFrontMatter<S>(readFileSyncUTF8(relativeToAbsolute(e.path)));\n          return {\n            nextmd: fileNextmd,\n            frontMatter,\n            markdown: content,\n          };\n        } else {\n          return null;\n        }\n      })\n      .flatMap((e) => (e ? [e] : []));\n\n    return {\n      props: {\n        ...pageData,\n        nextmd,\n        subPaths,\n      },\n    };\n  };\n\n  return {\n    getStaticPaths: async () => {\n      const allFiles = await getAllFiles();\n\n      return {\n        paths: allFiles\n          .filter((e) => isDraft(e.path) === false)\n          .map((e) => ({\n            params: {\n              nextmd: generateNextmd(e.path),\n            },\n          })),\n        fallback: false, // See the \"fallback\" section below\n      };\n    },\n\n    getStaticProps: async (context: { params?: { nextmd: string[] } }): Promise<{ props: NextMarkdownProps<T, U> }> => {\n      const nextmd = context.params?.nextmd;\n\n      return getStaticPropsForNextmd<T, U>(nextmd ?? []);\n    },\n\n    getStaticPropsForNextmd,\n  };\n};\n\nexport default NextMarkdown;\nexport * from './types';\n"],"names":[],"version":3,"file":"types.d.ts.map"}